# Conceitos B√°sicos e Aplica√ß√µes de Software

O software √© um segmento de instru√ß√µes que ser√£o analisadas e processadas pelo computador, com o objetivo de executar tarefas espec√≠ficas. Os softwares comandam o funcionamento de qualquer computador, por serem a parte l√≥gica que fornece explica√ß√µes para o hardware do computador.

√â considerado uma tecnologia √∫nica e mais importante do cen√°rio mundial. Para Pressman e Maxim (2016, p. 1):

> Abrange programas execut√°veis em um computador de qualquer porte ou arquitetura, conte√∫dos (apresentados a medida que os programas s√£o executados), informa√ß√µes descritivas tanto na forma impressa (*hard copy*) como na virtual.
> 

O software tamb√©m √© composto pela documenta√ß√£o associada a esses programas.

>[!note]
>üìå Software √© tanto um produto quanto um ve√≠culo que distribui o produto.

Softwares de computadores s√£o a tecnologia mais importante no cen√°rio mundial, s√£o incorporados a sistemas de todas as √°reas: log√≠stica, medicina, telecomunica√ß√µes, militar, industrial, entretenimento, setor p√∫blico etc. A medida que aumenta a import√¢ncia do software foram se criando novas tecnologias que tornam mais f√°cil, barato e r√°pido o desenvolvimento e manuten√ß√£o de computadores de alta qualidade.

Atualmente a import√¢ncia dos softwares se mostra no produto que ele entrega, que √© o mais importante desta era dos dados, a **informa√ß√£o.** Atrav√©s deles os dados s√£o transformados gerando e gerenciando informa√ß√µes, fornece um portal de redes mundial mas, ao mesmo tempo, amea√ßa a privacidade pessoal e tamb√©m permite crimes. 

Segundo Pressman e Maxim (2016), software possui pelo menos tr√™s caracter√≠sticas que o diferenciam do hardware:

1. **O software √© desenvolvido ou passa por um processo de engenharia**, n√£o sendo fabricado no sentido cl√°ssico. Os custos do software se concentram no processo de engenharia e, por consequ√™ncia disso, n√£o podem ser conduzidos como se fossem projetos de fabrica√ß√£o.
2. **Software n√£o se desgasta.** Podem ocorrer problemas iniciais com o software, pois alguns defeitos podem passar pela etapa de valida√ß√£o, por√©m o software n√£o sofre com intemp√©ries do passar do tempo nem do ambiente. Quando um software apresenta falhas, n√£o h√° como, simplesmente trocar algum componente, como acontece no hardware, o problema presentado no software pode ser de projeto ou de requisito mal definidos, o que leva o software a sofre manuten√ß√£o, a qual pode ser considerada mais complexa do que a do hardware. 
3. **A maioria dos softwares continua a ser constru√≠da de forma personalizada (sob encomenda) embora a ind√∫stria caminhe para constru√ß√£o com base em componentes.** Os componentes reutiliz√°veis de software s√£o criados para que o desenvolvedor possa se concentrar nas partes do projeto que representam algo novo. Esses componentes encapsulam dados e o processamento aplicado a eles, possibilitando a cria√ß√£o de novas aplica√ß√µes a partir de partes reutiliz√°veis.

---

# Hist√≥ria da Engenharia de Software

A principal caracter√≠stica da engenharia de software s√£o m√©todos e t√©cnicas que s√£o utilizadas para o desenvolvimento do software.

A engenharia de software foi mencionada pela primeira vez em uma confer√™ncia da Organiza√ß√£o do Tratado do Atl√¢ntico Norte (OTAN), conduzida na Alemanha em 1968. O objetivo era de **aplicar t√©cnicas e utilizar ferramentas na √°rea da computa√ß√£o, para desenvolvimento e a produ√ß√£o de software.** A√ß√µes como planejar a curto e longo prazo, a equipe que ser√° escalada, bem como a qualidade do produto e do seu processo.

Engenharia de Software √© uma disciplina com foco no desenvolvimento de sistemas de software de alta qualidade por um custo acess√≠vel, preocupando-se com todos os aspectos da produ√ß√£o, desde os est√°gios iniciais de especifica√ß√£o de um sistema at√© a manuten√ß√£o do sistema ap√≥s ter sido posto em uso. 

Essa disciplina ou √°rea do conhecimento se formou em decorr√™ncia da preocupa√ß√£o em contornar a crise que se abatia no software e lhe atribuiu um tratamento de engenharia, surgindo em 1970, com objetivo de implementar sistemas mais complexos. 

Al√©m disso os regulamentos que seus membros devem seguir inclui diretivas para a aquisi√ß√£o de conhecimento por parte de seus membros e diretivas para as pr√°ticas comportamentais de seus membros.

A engenharia de software √© importante, principalmente, por dois motivos:

1. Produ√ß√£o de sistemas confi√°veis, de maneira econ√¥mica e r√°pida.
2. Mais barato usar m√©todos e t√©cnicas propostas pela engenharia de software, pois para a maioria dos sistemas, o maior custo est√° em sua manuten√ß√£o.

---

# Tipos de Aplica√ß√£o de Software

Atualmente o software √© utilizado em praticamente todas as atividades exercidas pelas pessoas, sendo assim s√£o divididos em sete grandes categorias: 

- **Software de sistema:** s√£o os programas desenvolvidos para atender a outros. Exemplo: editores de texto, compiladores, utilit√°rios para gerenciamento de arquivos, sistemas operacionais e softwares de rede.
- **Software de aplica√ß√£o:**  programas independentes, desenvolvidos para solucionar uma necessidade espec√≠fica de neg√≥cio, ao processarem dados comerciais ou t√©cnicos, de forma que ajuda nas opera√ß√µes comerciais ou nas tomadas de decis√£o pelos administradores de empresa. Exemplo ERP (Enterprise Resource Planning) visa integra√ß√£o de todos so dados e processos de uma organiza√ß√£o em um sistema √∫nico.
- **Software de engenharia/cient√≠fico:** s√£o aplica√ß√µes com uma extensa variedade de programas especializados, astronomia √† vulcanologia, por exemplo. Normalmente utilizam algoritmos para o processamento num√©rico pesado.
- **Software embarcado:** s√£o residentes em um produto ou sistema e s√£o utilizados para controlar ou gerenciar caracter√≠sticas ou fun√ß√µes para o pr√≥prio sistema ou usu√°rio. Exemplo: painel de micro-ondas.
- **Software para linha de produtos:** s√£o sistemas criados especificamente para uma linha de produtos, exemplo software criados por empresas de marketing para artistas que utilizaram o software para gerenciar suas carreiras.
- **Aplica√ß√µes web/aplicativos m√≥veis:** categoria de software voltadas para navegadores e residentes em dispositivos m√≥veis.
- **Software de intelig√™ncia artificial:** utilizam algoritmos n√£o num√©ricos para solucionar problemas complexos. Exemplo: sistemas especialistas rob√≥tica, redes neurais artificiais.

## Software Legado

S√£o os softwares mais antigos e t√™m uma cont√≠nua aten√ß√£o, desde os anos 1960, por ainda serem usados enquanto suporte para fun√ß√µes de neg√≥cio vitais e consideradas indispens√°veis.

Um exemplo s√£o softwares de contabilidade, com a quantidade de regras, leis e detalhes no sistema tribut√°rio brasileiro, desenvolver um software do zero √© invi√°vel, portanto muitas empresas optam por utilizar um software antigo e a partir dele, integrar com novas tecnologias, atrav√©s de tecnologias de interface como o XML.

Esses softwares podem apresentar projetos n√£o expans√≠veis (aplica√ß√µes que s√≥ podem rodar no Windows por exemplo), c√≥digo intrincado, documenta√ß√£o inexistente ou escassa e testes que nunca foram arquivados, al√©m de pessoas que participaram do desenvolvimento n√£o estarem mais na equipe.

Mesmo assim √© importante ressaltar que esses softwares atendem a uma necessidade de seus usu√°rios, possibilitando confian√ßa e vitalidade, portanto n√£o precisam ser "consertados", entretanto sistemas tentem a evoluir com o passar do tempo pelas seguintes raz√µes:

- Softwares devem ser adaptados para atender √†s necessidades de novos ambientes ou tecnologias computacionais.
- Devem ser aperfei√ßoados para implementar novos requisitos de neg√≥cio.
- Expans√£o para funcionar com outros bancos de dados ou com sistemas mais modernos.
- Rearquitetado para torn√°-lo vi√°vel dentro de um ambiente computacional em evolu√ß√£o.

O objetivo da engenharia de software moderna √© o de elaborar metodologias baseadas na evolu√ß√£o, os softwares modificam-se continuamente e novos s√£o constru√≠dos a partir dos antigos.

## A Natureza Mutante do Software

Quatro categorias de software mais amplas dominam a evolu√ß√£o do setor:

### WebApps

Com o crescimento da linguagem HTML, foi poss√≠vel oferecer uma alta capacidade computacional e, com isso, nasciam os sistemas e aplica√ß√µes baseados na Web.

### Aplicativos M√≥veis

S√£o os softwares popularmente conhecidos como 'Apps', abrevia√ß√£o do termpo aplica√ß√£o de software. S√£o baixados em lojas on-line e podem ser classificados em:

1. **Ferramentas de suporte para produtividade.** Exemplo: editores, planilhas, gravadores, etc.
2. **Ferramentas de recupera√ß√£o de informa√ß√£o**. Exemplo: calend√°rio, agenda telef√¥nica, correio eletr√¥nico, informa√ß√µes clim√°ticas, etc.

<aside>
üìå **A diferen√ßa de uma aplica√ß√£o web e um aplicativo m√≥vel:**
Um webapp permite que um dispositivo m√≥vel tenha acesso a conte√∫do baseado na web por meio de um navegador especificamente projetado para se adaptar aos pontos fortes e fracos da plataforma m√≥vel. 
Um aplicativo m√≥vel pode acessar diretamente as caracter√≠sticas do hardware do dispositivo (por exemplo aceler√¥metro ou localiza√ß√£o por GPS)

</aside>

### Computa√ß√£o em Nuvem

A computa√ß√£o em nuvem √© definida como "infraestrutura ou ecossistema que permite a qualquer usu√°rio em qualquer lugar, utilizar um dispositivo de computa√ß√£o para compartilhar recursos computacionais em grande escala".

![Figura 1 - Arquitetura l√≥gica de computa√ß√£o em nuvem](1figura.jpg)

Figura 1 - Arquitetura l√≥gica de computa√ß√£o em nuvem

Assim, um dispositivo de computa√ß√£o externa acessa a nuvem por meio de um navegador Web; diante disso, a nuvem fornece o acesso aos dados armazenados em bancos de dados ou em estruturas de dados, como fila.

### Software para Linha de Produto

√â um conjunto, grupo de softwares ou, ainda, **uma fam√≠lia de sistemas que compartilha caracter√≠sticas ou especifica√ß√µes comuns, as quais satisfazem as estrat√©gias de mercado**, um dom√≠nio de aplica√ß√µes. 

A principal caracter√≠stica desses softwares √© o fato de serem desenvolvidos a partir de um conjunto de artefatos, reutilizando componentes, especifica√ß√µes de requisitos, casos de teste e outros, os quais podem ser utilizados para o desenvolvimento de novas aplica√ß√µes que possuem um mesmo dom√≠nio.

---

# Processos de Software

Para que um software seja produzido s√£o necess√°rias diversas etapas compostas por uma s√©rie de tarefas. Esse conjunto denomina-se **processo de software**.

>[!note]
>üìå **Processo de Software** √© um conjunto de atividades necess√°rias para definir, desenvolver, testar e manter um produto de software de alta qualidade. Apesar de possuir atividades essenciais para sempre entregar um software dentro do prazo e com boa qualidade, sua abordagem √© adapt√°vel.

O objetivo do processo de software √© de definir quais/o que as atividades que ser√£o executadas ao longo do projeto, quando ser√£o realizadas estabelecendo prazos, como que ser√° desenvolvido ou seja, quais as ferramentas e tecnologias ser√£o utilizadas e quem, definindo o time que ser√° respons√°vel pelo projeto. 

S√£o quatro **atividades fundamentais** para a engenharia de software:

1. Especifica√ß√£o de software
2. Projeto e implementa√ß√£o de software
3. Valida√ß√£o de software
4. Evolu√ß√£o de software

Essas atividades podem ser organizadas pelas empresas, da forma que acharem melhor, contudo todas as atividades s√£o de extrema import√¢ncia e o processo de software adotado pela empresa n√£o deve deixar de considerar nenhuma das etapas.

Dependendo do software a ser desenvolvido, pode ser utilizado um determinado processo de software, o rearranjo das atividades podem ser realizado a depender do tipo de software a ser produzido.

## Modelos de Processos de Software

Existem modelos de processo de software √© uma representa√ß√£o abstrata, simplificada de um processo de software, que organizam as atividades, os artefatos que devem ser produzidos em cada uma das atividades (documentos) e os pap√©is das pessoas envolvidas na engenharia de software. 

Existem diversos modelos descritos na literatura, os tr√™s principais s√£o:

1. Modelo em Cascata (Ciclo de Vida Cl√°ssico)
2. Modelo de Desenvolvimento Incremental
3. Engenharia de Software Orientada a Reuso

### Modelo em Cascata

Paradigma mais antigo da engenharia de software, sugere uma abordagem sequencial e sistem√°tica para o desenvolvimento. Inicia-se na defini√ß√£o dos requisitos por parte do cliente, avan√ßando para as atividades de projeto e implementa√ß√£o de software, culminando no suporte cont√≠nuo do software e conclu√≠do por meio de testes.

Os principais est√°gios do modelo demonstram as atividades fundamentais do desenvolvimento:

1. **An√°lise e defini√ß√£o dos requisitos:** As fun√ß√µes, as restri√ß√µes e os objetivos do sistema s√£o definidos a partir de consulta aos usu√°rios.
2. **Projeto de sistemas e de software:** Agrupa os requisitos em sistemas de hardware ou de software, estabelecendo a arquitetura do sistema geral. Envolve a identifica√ß√£o e a descri√ß√£o das abstra√ß√µes fundamentais do sistema de software e suas rela√ß√µes.
3. **Implementa√ß√£o e teste de unidades:** Esse est√°gio, o projeto √© implementado (codificado) at√© sua compreens√£o de um conjunto de programas ou unidades de programa. O teste de unidades envolve a verifica√ß√£o se cada unidade atende a suas especifica√ß√µes.
4. **Integra√ß√£o e teste de sistemas:** As unidades de programa s√£o integradas e testadas como um sistema completo. Depois dos testes, o sistema de software √© entregue ao cliente.
5. **Opera√ß√£o e manuten√ß√£o:** A manuten√ß√£o envolve corrigir erros que n√£o foram descobertos em est√°gios anteriores do ciclo de vida, melhorando a implementa√ß√£o das unidades de sistema e aumentando as fun√ß√µes desse sistema √† medida que novos requisitos s√£o descobertos  

Um est√°gio s√≥ pode ser iniciado depois que o anterior tenha sido conclu√≠do, embora, na pr√°tica, esses est√°gios se sobrep√µem e alimentam uns aos outros de informa√ß√£o.

**Alguns problemas que podem ser encontrados quando o modelo em cascata √© aplicado:**

1. Alguma itera√ß√£o, entre as etapas, sempre ocorre e traz problemas na aplica√ß√£o do paradigma.
2. Na maioria das vezes, o cliente n√£o consegue definir claramente todas as suas necessidades e o modelo em cascata requer essa defini√ß√£o no in√≠cio das atividades.
3. Uma vers√£o operacional do sistema somente estar√° dispon√≠vel no final do projeto, ou seja, o cliente n√£o tem nenhum contato como sistema durante o seu desenvolvimento.

O modelo em cascata deve ser utilizado somente quando os requisitos s√£o fixos e com pouca probabilidade de altera√ß√£o durante o desenvolvimento do sistema ou se o trabalho de ser realizado de forma linear at√© sua finaliza√ß√£o.

### Modelo de Desenvolvimento Incremental

Tem como base a ideia de desenvolver uma implementa√ß√£o inicial, exp√¥-la aos coment√°rios do usu√°rio e continuar por meio da cria√ß√£o de v√°rias vers√µes at√© que um sistema adequado seja desenvolvido. Tem como objetivo fornecer pequenos entreg√°veis desde o in√≠cio do projeto.

As atividades de especifica√ß√£o, desenvolvimento e valida√ß√£o s√£o realizadas concorrentemente com um r√°pido feedback entre todas as atividades.

**POC's (Proof of concept)**

Algumas vantagens importantes:

- Se o cliente mudar seus requisitos, o custo ser√° reduzido, pois a quantidade de an√°lise e a documenta√ß√£o a ser refeita ser√£o menores do que no modelo de cascata.
- Clientela acompanha o desenvolvimento do software √† medida que novas vers√µes lhe s√£o apresentadas.
- Os clientes podem come√ßar a utilizar o software logo que as vers√µes iniciais forem disponibilizadas.

A partir de uma perspectiva de engenhar e de gerenciamento, existem alguns problemas:

1. **O processo n√£o √© vis√≠vel:** os gerentes necessitam que o desenvolvimento seja regular, para que possam medir o progresso. N√£o √© vi√°vel produzir documentos que reflitam cada vers√£o do sistema.
2. **Os sistemas frequentemente s√£o mal estruturados:** as mudan√ßa constante tende a corromper a estrutura do software. Assim incorporar modifica√ß√µes no software torna-se cada vez mais dif√≠cil e oneroso
3. **Podem ser exigidas ferramentas e t√©cnicas especiais:** elas possibilitam r√°pido desenvolvimento, mas podem ser incompat√≠veis com outras ferramentas ou t√©cnicas, al√©m disso relativamente poucas pessoas podem ter a habilita√ß√£o necess√°ria para utiliz√°-las.

Para sistemas pequenos ou de porte m√©dio, com tempo de vida razoavelmente curto, a abordagem incremental de desenvolvimento talvez seja a melhor op√ß√£o. Para sistemas de grande porte, com longo tempo de vida e v√°rias equipes desenvolvendo diferentes partes do sistema, os problemas da metodologia de desenvolvimento incremental tornam-se particularmente graves. 

### Engenharia de Software Orientada a Reuso

Na maioria dos projetos de software, ocorre algum reuso de software, normalmente, a equipe que trabalha no projeto conhece projetos ou c√≥digos an√°logos ao que est√° sendo desenvolvido. Busca-se esses c√≥digos, modifica-os conforme a necessidade do cliente e as incorpora em seus sistemas.

A abordagem orientada a reuso conta com um grande n√∫mero de componentes de software reutiliz√°veis que podem ser acessados e com um framework de integra√ß√£o para esses componentes. √Äs vezes, esses componentes s√£o sistemas propriamente ditos (COTS - Commercial Off-The-Shelf - ou Sistemas Comerciais de Prateleira).

As etapas de especifica√ß√£o de requisitos e de valida√ß√£o s√£o compar√°veis com outros processos. As etapas s√£o:

1. **Analise de componentes:** considerando a especifica√ß√£o de requisitos, √© feita uma busca de componentes para implementar essa especifica√ß√£o. Pode ser fornecida somente parte da funcionalidade requerida.
2. **Modifica√ß√£o de requisitos:** os requisitos s√£o analisados, levando-se em considera√ß√£o as informa√ß√µes sobre os componentes que foram encontrados na etapa anterior. Se for poss√≠vel os requisitos s√£o, ent√£o, modificados. Quando isso n√£o for poss√≠vel, a etapa de an√°lise de componentes dever√° ser refeita a fim de buscar outras solu√ß√µes.
3. **Projeto do sistema com reuso:** durante essa etapa, o framework do sistema √© projetado ou, ent√£o alguma infraestrutura existente √© reutilizada. Se os componentes reus√°veis n√£o estiverem dispon√≠veis, pode ser necess√°rio que um novo software deva ser projetado.
4. **Desenvolvimento e integra√ß√£o:** O software que n√£o puder ser comprado dever√° ser desenvolvido e os componentes e sistemas COTS ser√£o integrados.

N√£o h√° como evitar as altera√ß√µes nos requisitos dos usu√°rios e isso pode acabar levando ao desenvolvimento de um sistema que n√£o atenda √†s suas reais necessidades. A possibilidade de que o controle da evolu√ß√£o do sistema fique comprometido, devido as novas vers√µes dos componentes reus√°veis n√£o estarem sob controle da organiza√ß√£o que as utiliza.

A abordagem baseada no reuso tem a vantagem de propiciar uma entrega mais r√°pida do software e consequentemente a diminui√ß√£o dos custos de desenvolvimento, bem como seus riscos

### Atividades B√°sicas do Processo de Software

Os modelos de processo de software possuem algumas atividades em comum, algumas vezes, organizados de forma diferente, dependendo do processo de software que est√° sendo considerado.

A maneira como as atividades ser√£o realizadas depende do tipo de software, das pessoas e da organiza√ß√£o envolvida.

As atividades b√°sicas do processo de software s√£o quatro: **a especifica√ß√£o, o projeto e a implementa√ß√£o, a valida√ß√£o e a evolu√ß√£o.**

**Especifica√ß√£o de Software**

Objetivo definir quais fun√ß√µes s√£o requeridas pelo sistema e identificar as restri√ß√µes sobre a opera√ß√£o e o desenvolvimento desse sistema, √© uma atividade importante e cr√≠tica, se n√£o bem realizada acarretam em problemas posteriores no projeto e na implementa√ß√£o do sistema. 

> Objetivo produzir um documento de requisitos acordados que especifica um sistema que satisfaz os requisitos dos *stakeholders*.
> 

Esta atividade √© composta por quatro fases:

1. **Estudo de viabilidade:** uma avalia√ß√£o √© realizada para verificar as necessidades do usu√°rios, se podem ser atendidas com base nas tecnologias de software e hardware dispon√≠veis na empresa, al√©m da viabilidade comercial e as restri√ß√µes or√ßament√°rias existentes. 
2. **Levantamento e an√°lise de requisitos:** nesta fase faz-se um levantamento dos requisitos do sistema, baseando-se em sistema j√° existentes, na consulta dos usu√°rios e compradores em potencial. Pode envolver a elabora√ß√£o de modelos e prot√≥tipos a fim de ajudar a equipe de desenvolvimento compreender melhor o sistema.
3. **Especifica√ß√£o de requisitos:** atividade que visa traduzir as informa√ß√µes coletadas nas fases anteriores em um documento que define um conjunto de requisitos dos usu√°rios e os de sistema.
4. **Valida√ß√£o de requisitos:** nessa atividade avalia-se os requisitos levantados quanto a sua pertin√™ncia, consist√™ncia e integralidade. Os requisitos que apresentarem problemas devem ser corrigidos nessa etapa, afim que a documenta√ß√£o final fique correta.

As etapas de an√°lise, defini√ß√£o e especifica√ß√£o de requisitos s√£o intercaladas, pois novos requisitos surgem ao longo do processo, alimentando de informa√ß√µes umas as outras.

**Projeto e Implementa√ß√£o de Software**

Processo de convers√£o de uma especifica√ß√£o do sistema em um execut√°vel. O projeto de software cria uma representa√ß√£o ou modelo do software, fornecendo detalhes sobre a arquitetura, estruturas de dados, interfaces e componentes fundamentais.

**O in√≠cio do projeto ocorre assim que os requisitos tiverem sido analisados e modelados**. Com base no documento de requisitos, o engenheiro de software, na fase de modelagem do sistema, dever√° elaborar os diagramas da UML - Unified Modeling Language, como o diagrama de caso de uso e o diagrama de classes, por exemplo.

Na fase de projeto do sistema, o engenheiro dever√°:

1. Definir o diagrama geral do sistema;
2. Elaborar as interfaces com o usu√°rio;
3. Desenvolver um conjunto de especifica√ß√µes de caso de uso.

Durante o projeto, o analista deve definir cada componente do sistema ao n√≠vel de detalhamento para sua implementa√ß√£o em uma determinada linguagem de programa√ß√£o. 

A programa√ß√£o, √© a fase de implementa√ß√£o de um projeto t√≠pico e envolve a escrita de instru√ß√µes em alguma linguagem de programa√ß√£o com objetivo de implementar o que foi modelado na etapa do projeto.

Normalmente os programadores testam os c√≥digos fontes que eles mesmos desenvolveram, a fim de descobrirem defeitos. Esse processo √© chamado de depura√ß√£o. 

O teste estabelece a exist√™ncia de defeitos, enquanto a depura√ß√£o se ocupa em localizar e corrigir esses defeitos. O processo de depura√ß√£o √© parte tanto do desenvolvimento quanto do teste de software.

**Valida√ß√£o de Software**

A valida√ß√£o de software se dedica em mostrar que um sistema atende tanto as especifica√ß√µes de requisitos quanto as expectativas dos seus usu√°rios. A principal t√©cnica de valida√ß√£o √© o teste de programa, onde o sistema √© executado com dados de teste simulados. Caso o sistema for grande e constru√≠do a partir de subsistemas e m√≥dulos o processo de testes deve evoluir em est√°gios, sendo realizados de forma incremental, iterativa.

Na literatura √© proposto um processo de tr√™s est√°gios. O primeiro √© o teste de componente, em seguida tem-se o sistema integrado e testado, por fim o sistema √© testado com dados reais. 

**Evolu√ß√£o de software**

Depois que o software √© colocado em funcionamento, com certeza, ocorrer√£o **mudan√ßas que levar√£o √† altera√ß√£o desse software**. Essas altera√ß√µes podem ser para corre√ß√£o de erros n√£o detectados durante a etapa de valida√ß√£o do software, quando h√° adapta√ß√µes a um novo ambiente, quando o cliente solicita novas caracter√≠sticas ou fun√ß√µes, ou quando a aplica√ß√£o passa por um processo de reengenharia.

Normalmente, os custos de manuten√ß√£o s√£o maiores do que os custos de desenvolvimento inicial.

---

# Metodologias √Ågeis

As metodologias √°geis s√£o reconhecidas por terem menos regras, serem menos burocr√°ticas e mais flex√≠veis, permitindo ajustes durante o desenvolvimento do software.

Al√©m disso possuem um baixo custo de controle de processos e entregas r√°pidas contribuindo para qualquer tipo de empresa. √â √°gil pois s√£o conduzidos com base em requisitos que modificam rapidamente.

As metodologias tradicionais, devem ser utilizadas em situa√ß√µes em que os requisitos do sistema s√£o est√°veis. Se os requisitos forem pass√≠veis de mudan√ßas e a equipe for pequena, √© interessante utilizar as metodologias √°geis.

Em todas as atividades que est√£o ligadas os processos de desenvolvimento, temos uma forte documenta√ß√£o que deve ser considerada. 

>[!note]
>üìå S√£o uma abordagem ao modelo de gest√£o tradicional de projetos. O modelo de entrega √°gil √© baseado em **ciclos iterativos** e **incrementais**, o que traz **flexibilidade** e **adaptabilidade**. Algumas caracter√≠stica importantes s√£o a **inspe√ß√£o** e **adapta√ß√£o** dos ciclos e itera√ß√µes, focados em gerar **melhoria cont√≠nua** para as equipes e processos. Seu foco √© **agregar valor ao cliente.**

## Manifesto √Ågil

Em 2001 um grupo de 17 pessoas se reuniram para discutir sobre uma nova abordagem de gest√£o de projetos de software.

O manifesto √© composto por quatro valores:

- **Indiv√≠duos e itera√ß√µes** mais que processos e ferramentas.
- **Software em funcionamento** mais que documenta√ß√£o abrangente
- **Colabora√ß√£o com o cliente** mais que negocia√ß√£o de contratos.
- **Responder a mudan√ßas** mais que seguir o plano

Alguns exemplos de metodologias e frameworks dispon√≠veis s√£o: XP (Extreme Programming), Scrum, Crystal, TDD (Test Driven Development), FDD (Feature Driven Development) e Kanban.

## Extreme Programming (XP)

Utilizando uma abordagem orientada a objeto, a XP considerada uma metodologia √°gil, tem como base para condu√ß√£o de projetos, requisitos que se modificam rapidamente.

Sua ideia b√°sica √© enfatizar o desenvolvimento r√°pido do projeto, visando garantir a satisfa√ß√£o do cliente favorecendo o cumprimento das estimativas.

Tendo como meta atender as necessidades do cliente com mais qualidade, rapidez e de forma simples, mesmo que os requisitos se alterem com frequ√™ncia, dando a prefer√™ncia com desenvolvimento orientado a objetos, permite trabalhar com equipes de at√© 12 desenvolvedores.

Al√©m disso essa metodologia trabalha implementando melhorias ou mudan√ßas conforme o sistema √© utilizado. Com isso o cliente sempre tem um sistema que pode utilizar, testar e avaliar.

### Valores Fundamentais do XP:

- **Comunica√ß√£o:** foca em construir um entendimento da pessoa com o problema.
- **Simplicidade:** faz aquilo que √© mais simples hoje e cria um ambiente em que o custo de mudan√ßas no futuro seja baixo.
- **Feedback R√°pido:** programadores e clientes se comunicando frequentemente.
- **Coragem:** alterar c√≥digo j√° escrito e que est√° funcionando.
- **Presumir Simplicidade:** todo problema deve ser tratado para ser resolvido de forma mais simples poss√≠vel
- **Mudan√ßas Incrementais:** mudan√ßas devem ser incrementais e feitas aos poucos.
- **Abra√ßar Mudan√ßas:** mudan√ßas devem ser sempre bem vindas.
- **Trabalho de Qualidade:** ter um sistema que atenda aos requisitos do cliente, que rode 100% dos casos de teste e que agregue o maior valor poss√≠vel para o neg√≥cio do cliente.

## Scrum

Tem como base a ideia de que equipes de projeto pequenas e multifuncionais produzem resultados melhores.

Segundo seus idealizadores Jeff Sitherland e Ken Schwabe, *Scrum* √© um *framework* para desenvolver e manter produtos complexos. √â uma metodologia √°gil de software que concentra as suas aten√ß√µes no produto final, com um r√°pido desenvolvimento, e nas intera√ß√µes dos indiv√≠duos.

*Scrum* possui algumas caracter√≠sticas importantes que s√£o: flexibilidade de resultados e prazos, trabalho com equipes pequenas, uso de revis√µes frequentes, colabora√ß√£o dos interessados e se baseia na orienta√ß√£o a objetos.

As atividades executadas s√£o divididas em ciclos chamados de ***sprints***, cada *sprint* tem uma dura√ß√£o vari√°vel durante o desenvolvimento do projeto, a depender da avalia√ß√£o da equipe. 

Al√©m disso o Scrum estipula um conjunto de pr√°ticas e regras que devem ser seguidas pela equipe. Nele existem tr√™s **papeis** importantes: *Product Owner (PO)*, *Scrummaster* e *Team,* bem como as cerim√¥nias que s√£o dividas em quatro: *Daily Meeting* (*Daily Scrum*), *Sprint Review*, *Sprint Planning* e *Sprint Retrospective*.

### Cerim√¥nias

**Sprint Planning**

Ou planejamento Sprint, √© a primeira reuni√£o do projeto onde todos devem participar, tendo dura√ß√£o m√°xima de 8 horas. Nessa reuni√£o em que o *Product Owner* planeja e elabora a lista de prioridades.

**Daily Meeting (Daily Scrum)**

Ou reuni√£o di√°ria √© onde cada membro do time deve responder o que j√° foi feito e o que pretende fazer e se h√° algum impedimento para conclus√£o. Como o pr√≥prio nome j√° diz, √© uma reuni√£o que ocorre diariamente com dura√ß√£o m√°xima de 15 minutos, com participa√ß√£o do time e o *Scrum Master*.

**Sprint Review**

Ou revis√£o do *sprint*, √© o balan√ßo de tudo que foi feito durante uma *sprint*. Aqui s√£o mostrados apenas os resultados conclu√≠dos para o *Product Owner* e convidados. 

**Sprint Retrospective**

Ou retrospectiva da *sprint* tem como objetivo verificar o que foi positivo e o que pode ser melhorado na *sprint*. 

A partir dessas cerim√¥nias s√£o gerados os artefatos, que s√£o documentos, na metodologia Scrum temos *Product Backlog*, *Sprint Backlog* e o *Burndown Chart*.

### Fluxo geral do processo

Tudo se inicia no ***Product Backlog***, que √© uma lista de prioridades dos requisitos ou de funcionalidades para o projeto, tamb√©m s√£o estimados os custos, riscos e definidas as ferramentas de desenvolvimento, a equipe e as datas de entregas. 

Com o *product backlog* definido, a equipe passa a realizar o ***Sprint Backlog*** onde s√£o discutidas a lista de funcionalidades que ser√£o realizadas no pr√≥ximo *sprint*, al√©m de definidas as fun√ß√µes de cada membro do time.

A cada *sprint* s√£o necess√°rios um preparo, para isso √© feito um levantamento junto ao cliente, analisado e entendido para detalhamento dos itens a serem trabalhados durante o *sprint*. Ao final um incremento do produto √© apresentado ao cliente, caso surjam defeitos, eles devem ser inclu√≠dos no *backlog* do produto para que seja trabalhado nas pr√≥ximas *sprints*. 

Conforme o ciclo de desenvolvimento ocorre s√£o adotados mecanismos de controle do Scrum que s√£o: controle de funcionalidades que n√£o foram entregues, mudan√ßas que podem ocorrer devido a defeitos corrigidos, problemas t√©cnicos e controle de riscos.

---
