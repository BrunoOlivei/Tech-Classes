# Introdu√ß√£o

Quando pensamos em qualidade, geramos muitas preocupa√ß√µes relacionadas com o gerenciamento de qualidade que podem ser resumidas em elementos que contribuem para organiz√°-la, assim como os padr√µes e normas de qualidade e os testes de software. 

Portanto, estudiosos e institutos preocupados, n√£o s√≥ com a qualidade de seus produtos e servi√ßos mas tamb√©m em garantir maior seguran√ßa para os usu√°rios criaram diversos padr√µes e normas de qualidade, como, por exemplo, CMMI e MPSBR.

# Introdu√ß√£o √† Qualidade de Software

A qualidade, em software, refere-se √†s caracter√≠sticas dos produtos que atendem os requisitos de funcionalidade. Esses requisitos est√£o ligados diretamente com a √°rea de utiliza√ß√£o do programa. 

Tais requisitos s√£o: 

- Funcionalidade;
- Confiabilidade;
- Usabilidade;
- Efici√™ncia;
- Manutenibilidade;
- Portabilidade;
- Estabilidade.

Esses requisitos fazem parte da qualidade do software de forma que cada produto, cada programa, possa atender as necessidades tecnol√≥gicas, econ√¥micas, sociais, intelectuais e pr√°ticas do setor ao qual se destinam, observando as especificidades de cada √°rea onde o produto √© utilizado. 

A qualidade visa apresentar um produto completo, que atenda todas as necessidades do setor ao qual se destina.

O termo qualidade possui v√°rias defini√ß√µes, as quais variam conforme a abordagem utilizada:

- **Conformidade com as especifica√ß√µes**: o gerenciamento da qualidade deve ser feito desde o in√≠cio do desenvolvimento, para evitar defeitos e diminuir o retrabalho (levantamento de requisitos e modelagem).
- **Adequa√ß√£o ao uso:** significa que as expectativas do cliente s√£o atendidas. Aqui h√° dois fatores a considerar, a qualidade obrigat√≥ria, em que o produto cumpre o que devia fazer, e a qualidade atrativa, onde o produto vai al√©m do que ele devia fazer.
- **NBR ISO 8402:** qualidade √© a totalidade das caracter√≠sticas de uma entidade que lhe confere a capacidade de satisfazer √†s necessidades expl√≠citas e impl√≠citas.
    - **Entidade:** √© o produto do qual estamos falando.
    - **Necessidades expl√≠citas:** s√£o expressas na defini√ß√£o de requisitos, s√£o as condi√ß√µes em que o produto deve ser utilizado, seus objetivos, fun√ß√µes e qual vai ser o seu desempenho esperado.
    - **Necessidades impl√≠citas:** n√£o s√£o expressas em documentos, mas s√£o necess√°rias para o usu√°rio durante o manuseio do produto no seu dia a dia.

No in√≠cio da d√©cada de 70 Bohem e McCall propuseram uma classifica√ß√£o para os fatores que afetam a qualidade de um produto de software, surgindo ent√£o os primeiros padr√µes para garantia de qualidade. 

Dessa forma programas de melhoria de qualidade bem-sucedidos propiciam um aumento de produtividade, redu√ß√£o no n√∫mero de defeitos no software, maior previs√£o e visibilidade dos processos definidos, al√©m do cumprimento das metas de custo, prazo, funcionalidade e aumento na motiva√ß√£o da equipe desenvolvedora.

---

## Fatores de Qualidade

McCall, Richards e Walters criaram uma proposta de categoriza√ß√£o dos fatores que afetam a qualidade de software. Eles se concentram em tr√™s importantes aspectos: r**evis√£o, a transi√ß√£o e a opera√ß√£o do produto de software:**

![56.fatores-qualidade-software.png](56.fatores-qualidade-software.png)

| Fator | Descri√ß√£o |
| --- | --- |
| Corre√ß√£o | O quanto um programa satisfaz a sua especifica√ß√£o e atende aos objetivos da miss√£o do cliente. |
| Confiabilidade | O quanto se pode esperar que um programa realize a fun√ß√£o pretendida com a precis√£o exigida. |
| Integridade | O quanto o acesso ao software ou dados por pessoas n√£o autorizadas pode ser controlado. |
| Usabilidade | Esfor√ßo necess√°rio para aprender, operar, preparar a entrada de dados e interpretar a sa√≠da de um programa |
| Facilidade de Manuten√ß√£o | Esfor√ßo necess√°rio para localizar e corrigir um erro em um programa e fazer a manuten√ß√£o. |
| Flexibilidade | Esfor√ßo necess√°rio para modificar um programa em opera√ß√£o, exemplo adicionar alguma funcionalidade, campo ou coluna. |
| Testabilidade | Esfor√ßo necess√°rio para testar um programa, de modo a garantir que ele desempenhe a fun√ß√£o destinada. |
| Portabilidade | Esfor√ßo necess√°rio para transferir um programa de um ambiente de hardware e/ou software para outro. |
| Reusabilidade | O quanto um programa [ou partes de um] pode ser reutilizado em outras aplica√ß√µes relacionadas ao empacotamento e o escopo das fun√ß√µes que o programa executa |
| Interoperabilidade | Esfor√ßo necess√°rio para integrar um sistema a outro. Um sistema de ERP integrando com um sistema de emiss√£o de NF, por exemplo. |

---

## Elementos de Garantia da Qualidade de Software

Quando pensamos em garantir a qualidade de software, temos muitas preocupa√ß√µes e atividades relacionadas com a gest√£o da qualidade:

| Elemento | Descri√ß√£o |
| --- | --- |
| Padr√µes | O IEEE, a ISO e outras organiza√ß√µes de padroniza√ß√£o produziram uma ampla gama de padr√µes para engenharia de software e seus respectivos documentos. Os padr√µes podem ser adotados voluntariamente por uma organiza√ß√£o de engenharia de software ou impostos pelo cliente ou outros interessados. |
| Revis√µes e Auditorias | As revis√µes t√©cnicas s√£o uma atividade de controle de qualidade realizada por engenheiros de software. Seu intuito √© o de revelar erros. |
| Testes | Os testes de software s√£o uma fun√ß√£o de controle de qualidade com um objetivo principal: o de descobrir erros e tamb√©m verificar se o que foi desenvolvido est√° em conformidade com o que o cliente solicitou. |
| Coleta e An√°lise de Erros/Defeitos | A √∫nica forma de melhorar e medir o nosso desempenho. Assim, deve-se reunir e analisar dados de erros e defeitos para melhor compreender como os erros s√£o introduzidos e quais atividades de engenharia de software melhor se ad√©quam para sua elimina√ß√£o. |
| Administra√ß√£o da Seguran√ßa | Com o aumento dos crimes cibern√©ticos e novas regulamenta√ß√µes governamentais referentes √† privacidade, toda organiza√ß√£o de software deve instituir pol√≠ticas que protejam os dados em todos os n√≠veis, estabelecer prote√ß√£o atrav√©s de firewalls para as aplica√ß√µes da Internet (WebApps) e garantir que o software n√£o tenha sido alterado internamente, sem autoriza√ß√£o. |
| Prote√ß√£o | O fato de o software ser quase sempre um componente fundamental de sistemas que envolvem vidas humanas (por exemplo, aplica√ß√µes na ind√∫stria automotiva ou aeron√°utica), o impacto de defeitos ocultos pode ser catastr√≥fico. Devemos avaliar o impacto de falhas de software e por iniciar as etapas necess√°rias para redu√ß√£o de riscos. |

---

## Normas e Modelos de Padr√µes de Qualidade de Software

As normas e modelos de padr√µes de qualidade de software s√£o a principal chave para a garantia da qualidade. Muitos s√£o aplicados na empresa na totalidade, mas h√° tamb√©m empresas que optam por adotar somente em um projeto, tamb√©m pode ser uma exig√™ncia do cliente. S√£o elas quem definem as caracter√≠sticas que todos os componentes de software devem possuir e como o processo de software deve ser condizido, para assegurar a qualidade do produto de software. Existem diversas normas e modelos criados, um delas √© a CMMI e a MPSBr.

---

### CMMI

O CMMI (Capability Maturity Model Integration ou Modelo integrado de Maturidade e Capacita√ß√£o), foi desenvolvido pelo SEI (Software Engineering Institute), √© o modelo desenvolvido para a melhoria da maturidade dos processos de desenvolvimento de software na empresa. 

√â um modelo para avaliar e melhorar a capacita√ß√£o das empresas que desenvolvem software, propondo etapas que levam a institui√ß√£o a se aprimorar continuamente em busca de solu√ß√µes para o seu crescimento com qualidade.

Os objetivos principais do CMMI envolvem:

- Auxiliar as empresas a se conhecerem. A partir disso, espera-se que elas melhorem seus processos de desenvolvimento e a manuten√ß√£o do software.
- Fornecer, √†s empresas, um controle de seus processos atrav√©s de uma estrutura conceitual e, com isso, obter a melhoria cont√≠nua de seus produtos de software.

<aside>
üö® O modelo n√£o diz como implementar determinadas pr√°ticas, ele apenas indica o que deve ser feito.

</aside>

Existem duas representa√ß√µes, uma cont√≠nua e outra em est√°gios, nas quais os modelos CMMI podem variar conforme a representa√ß√£o e o corpo de conhecimento escolhido pela empresa.

**Representa√ß√£o cont√≠nua**: √© caracterizada pelos n√≠veis de capacidade. O modelo descreve um caminho de melhoria de maturidade atrav√©s de cinco n√≠veis distintos, cada um com caracter√≠sticas individuais, as quais determinam qual √© a capacita√ß√£o do processo. Quanto maior o n√≠vel, maior √© a maturidade dos processos de desenvolvimento de software de uma empresa.

A etapa do n√≠vel 1, a empresa precisa se conhecer melhor, avaliando seu n√≠vel de gerenciamento e controle. 

![57-niveis-cmmi.png](57-niveis-cmmi.png)

**Representa√ß√£o em est√°gio:** foca nas melhores pr√°ticas que uma empresa pode utilizar. A maturidade √© medida por um conjunto de processos.

![58.representacao-estagio.png](58.representacao-estagio.png)

O quadro acima nos mostra que cada n√≠vel de maturidade √© composto por v√°rias √°rea-chaves de processo, as quais possuem objetivos espec√≠ficos e gen√©ricos. Cada objetivo espec√≠fico √© alcan√ßado atrav√©s de algumas pr√°ticas bem definidas. Cada objetivo gen√©rico especifica v√°rias funcionalidades comuns, as quais est√£o ligadas as pr√°ticas gen√©ricas. Essas pr√°ticas s√£o os detalhes operacionais que devem ser abordados pelo processo ou pela metodologia  de desenvolvimento usado na empresa.

O modelo CMMI fornece orienta√ß√£o para melhorias nos processos e nas habilidades organizacionais. Ele tamb√©m inclui o ciclo de vida de produtos e servi√ßos de um software, o qual abrange as fases de: concep√ß√£o, desenvolvimento, aquisi√ß√£o, entrega e manuten√ß√£o.

Este modelo se tornou conhecido pela riqueza de detalhes e pela sua completa descri√ß√£o do processo de software, influenciando outros modelos criados, como o MPSBr.

---

### MPSBr

O MPSBr √© um modelo de qualidade de processos de software voltado para caracter√≠sticas das empresas brasileiras, baseado no padr√£o CMMI, nas normas ISO/IEC 12207 e SPICE. Principal vantagem √© seu custo reduzido de certifica√ß√£o.

Ele est√° dividido em tr√™s componentes:

- Modelo de Refer√™ncia (MR-MPS): para servi√ßo e gest√£o de pessoas
- M√©todo de Avalia√ß√£o (MA-MPS)
- Modelo de Neg√≥cio (MN-MPS)

![59 ‚Äî Componentes do Modelo MPSBr](59-MPSBr.png)

59 ‚Äî Componentes do Modelo MPSBr

O MR-MPS √© um modelo de refer√™ncia para a melhoria do processo de software e apresenta sete n√≠veis de maturidade, que s√£o:

- **N√≠vel G ‚Äî Parcialmente gerenciado:** primeiro n√≠vel do modelo, √© composto pelos processos de ger√™ncia de projeto e ger√™ncia de requisitos.
- **N√≠vel F ‚Äî Gerenciado:** composto pelo n√≠vel G acrescido dos processos de ger√™ncia de configura√ß√£o, garantia da qualidade, medi√ß√£o e aquisi√ß√£o.
- **N√≠vel E ‚Äî Parcialmente Definido:** composto pelo n√≠vel F acrescido dos processos de treinamento, defini√ß√£o do processo organizacional, avalia√ß√£o e melhoria do processo organizacional e adapta√ß√£o do processo para ger√™ncia de projetos.
- **N√≠vel D ‚Äî Largamente Definido:** composto pelo n√≠vel E, acrescido dos processos de desenvolvimento de requisitos, solu√ß√£o t√©cnica, valida√ß√£o, verifica√ß√£o, integra√ß√£o de produto, instala√ß√£o de produto e libera√ß√£o de produto.
- **N√≠vel C ‚Äî Definido:** composto pelo n√≠vel D, acrescido dos processos de ger√™ncia de riscos e an√°lise de decis√£o e resolu√ß√£o.
- **N√≠vel B ‚Äî Gerenciado Quantitativamente:** √© composto pelo n√≠vel C, acrescido dos processos de desempenho do processo organizacional e ger√™ncia quantitativa de projeto.
- **N√≠vel A ‚Äî Em Otimiza√ß√£o:** n√≠vel mais elevado do modelo, composto pelo n√≠vel B e acrescido dos processos de inova√ß√£o e implanta√ß√£o na organiza√ß√£o, an√°lise e resolu√ß√£o de causas.

Cada n√≠vel de maturidade possui suas √°reas de processo, nas quais s√£o analisados os:

- **Processos fundamentais:** aquisi√ß√£o, ger√™ncia de requisitos, desenvolvimento de requisitos, solu√ß√£o t√©cnica, integra√ß√£o, instala√ß√£o e libera√ß√£o de produto.
- **Processos organizacionais:** ger√™ncia de projeto, adapta√ß√£o do processo para ger√™ncia de projeto, an√°lise de decis√£o e resolu√ß√£o, ger√™ncia de riscos, avalia√ß√£o e melhoria do processo organizacional, defini√ß√£o do processo organizacional, desempenho do processo organizacional, ger√™ncia quantitativa do projeto, an√°lise e resolu√ß√£o de causas, inova√ß√£o e implanta√ß√£o na organiza√ß√£o.
- **Processo de apoio:** garantia de qualidade, ger√™ncia de configura√ß√£o, valida√ß√£o, medi√ß√£o, verifica√ß√£o e treinamento.

Em seguida, apresentam-se os n√≠veis de capacidade, nos quais s√£o obtidos os resultados dos processos analisados:

- AP 1.1 ‚Äî O processo √© executado.
- AP 1.2 ‚Äî O processo √© gerenciado.
- AP 2.2 ‚Äî O produto de trabalho do processo gerenciados.
- AP 3.1 ‚Äî O processo √© definido.
- AP 3.2 ‚Äî O processo est√° implementado.

O MA-MPS √© um m√©todo de avalia√ß√£o para melhoria do processo de software e o seu objetivo √© o de orientar a realiza√ß√£o de avalia√ß√µes, em conformidade com a norma ISO/IEC 15504, em empresas que j√° implementaram o MR-MPS.

J√° o MN-MPS √© um modelo de neg√≥cio para melhoria do processo de software. 

---

# Teste de Software

A qualidade de software √© determinada pela qualidade dos processos usados durante a fase de desenvolvimento do software. 

Todo software deve sofrer um n√≠vel m√≠nimo de teste. Quanto maior o n√≠vel de complexidade do software, mais testes e t√©cnicas se tornam necess√°rios.

H√° alguns axiomas e conceitos que podem ser usados no processo de teste:

- N√£o √© poss√≠vel testar um programa completamente.
- Teste de software √© um exerc√≠cio baseado em risco.
- Teste n√£o mostra que bugs n√£o existem, mas sim, o contr√°rio.
- Quanto mais bugs s√£o encontrados, mais bugs poder√£o aparecer.

O teste de software tem, como objetivo, mostrar que um sistema corresponde com as especifica√ß√µes descritas no documento de requisitos e atende as expectativas do cliente comprador do sistema. A maior parte dos custos de valida√ß√£o √© observada depois da implementa√ß√£o, quando o sistema √© testado pelo usu√°rio final. 

Os testes de software n√£o podem provar que um produto funciona, mas apenas encontrar defeitos, geralmente possuem dois objetivos principais:

- Encontrar defeitos no software, para eles poderem ser corrigidos ou minimizados.
- Fornecer uma avalia√ß√£o geral de qualidade e uma estimativa das poss√≠veis falhas.

### Por que testar?

- Quando um c√≥digo defeituoso √© executado, falhas ocorrem.
- Um sistema com falhas gera insatisfa√ß√£o, ferimentos ou at√© a morte dos clientes e usu√°rios.

### Testamos para:

- Verificar se o sistema est√° fazendo o que foi solicitado pelo cliente, com base nos requisitos levantados.
- Garantir que o neg√≥cio n√£o vai correr riscos provocados por defeitos em produ√ß√£o.
- Assegurar qualidade do sistema.

<aside>
üí° Os desenvolvedores querem provar que "**algo funciona**".

</aside>

<aside>
üö® Os testadores querem provar que "**algo N√ÉO funciona**".

</aside>

> Analisando o esfor√ßo dos testes podemos perceber que √© mais f√°cil provar que "algo funciona" do que provar que "algo n√£o funciona".
> 

---

## Conceitos B√°sicos de Teste de Software

Um dos conceitos que devem ser vistos √© a diferen√ßa entre erro e defeito. 

Defeitos s√£o considerados parte do universo f√≠sico, s√£o provocados por pessoas e podem ocasionar erros em um software. Um defeito pode ocorrer em fun√ß√£o de desvios do que foi levantado na an√°lise de requisitos.

O teste de software √© muitas vezes conhecido como verifica√ß√£o e valida√ß√£o. A verifica√ß√£o diz respeito ao conjunto de tarefas que visa garantir que o software teve suas fun√ß√µes espec√≠ficas implementadas corretamente. A valida√ß√£o se constitui como um conjunto de tarefas que objetiva assegurar que o software foi criado e pode ser verificado com base nos requisitos do cliente.

<aside>
üí° **Verifica√ß√£o:** "Estamos construindo corretamente o sistema?"
**Valida√ß√£o:** "Estamos construindo o sistema correto?"

A primeira quest√£o diz respeito ao que foi constru√≠do, enquanto a segunda se refere ao entendimento do que era para ser constru√≠do.

</aside>

---

## T√©cnicas de Teste de Software e Tipos de Testes

As t√©cnicas de teste s√£o procedimentos t√©cnicos e gerenciais que ajudam na avalia√ß√£o e nas melhorias do processo de software. Podem ser utilizadas para classificar:

- Diferentes conceitos de testes de software.
- T√©cnicas que envolvem o design de testes e suas situa√ß√µes.
- T√©cnicas de execu√ß√£o de teste e organiza√ß√µes de testes de software.

A fase de testes de software pode ser dividida em duas t√©cnicas: funcional e estrutura.

### Testes funcionais

Garantem o atendimento aos requisitos do sistema, ou seja, que os requisitos est√£o corretamente codificados. S√£o conhecidos como testes de caixa preta

Utilizam as especifica√ß√µes do documento de an√°lise de requisitos e de projetos para definir os testes a serem realizados, sem considerar o seu comportamento interno, apenas o resultado produzido.

Esse teste pode encontrar fun√ß√µes incorretas ou que estejam faltando, erros de interface, erros em estruturas de dados ou acesso √† base de dados externas, erros de comportamento ou de desempenho e, por √∫ltimo, erros de inicializa√ß√£o e t√©rmino.

<aside>
üö® Se o tipo de sa√≠da n√£o ocorre, ent√£o houve uma situa√ß√£o de defeito.

</aside>

### Testes estruturais

Garantem que os sistemas sejam estruturalmente s√≥lidos e que funcionem no contexto t√©cnico em que ser√£o instalados. S√£o conhecidos como testes de caixa branca.

Essa t√©cnica n√£o √© desenhada para garantir que o sistema esteja funcionalmente correto, mas para ele ser estruturalmente robusto, estabelecendo os objetivos do teste com base em uma determinada implementa√ß√£o, analisando os detalhes do c√≥digo-fonte. Todas as varia√ß√µes originadas por estruturas de condi√ß√µes/repeti√ß√µes do c√≥digo s√£o testadas.

Portanto, essa categoria de teste, visa garantir que todos os caminhos independentes de um m√≥dulo sejam executados pelo menos uma vez, exercitando todas as decis√µes l√≥gicas nos seus estados verdadeiro e falso, executando todas as decis√µes l√≥gicas nos seus estados verdadeiro e falso, executando todos os ciclos em seus limites e dentro de suas fronteiras operacionais, por √∫ltimo, exercitando estruturas de dados internas para assegurar a sua validade.

A seguir uma lista com algumas categorias de testes que podem ser utilizados:

- **Teste de Unidade:** Teste em um n√≠vel de componente ou classe. √â o teste cujo objetivo √© um "peda√ßo de c√≥digo".
- **Teste de Integra√ß√£o:** Garante que um ou mais componentes combinados (ou unidades) funcionam. Podemos dizer que um teste de integra√ß√£o √© composto por diversos testes de unidade.
- **Teste Positivo-Negativo:** Garante que a aplica√ß√£o vai funcionar no "caminho feliz" de sua execu√ß√£o e funcionar√° no seu fluxo de exce√ß√£o.
- **Teste de Interface:** Verifica se a navegabilidade e os objetivos da tela funcionam assim como foram especificados e se atendem da melhor forma ao usu√°rio.
- **Teste de Aceita√ß√£o do Usu√°rio:** Testa se a solu√ß√£o ser√° bem vista pelo usu√°rio. Ex: caso exista um bot√£o pequeno demais para executar uma fun√ß√£o, isso deve ser criticado em fase de testes (aqui cabem quesitos fora da interface tamb√©m).
- **Teste de Volume:** Testa a quantidade de dados envolvidos (pode ser pouca, normal, grande ou al√©m de grande).
- **Testes de Configura√ß√£o:** Testa se a aplica√ß√£o funciona corretamente em diferentes ambientes de hardware ou de software.
- **Testes de Instala√ß√£o:** Testa se a instala√ß√£o da aplica√ß√£o foi bem sucedida.
- **Testes de Sistemas:** Testa a execu√ß√£o do sistema na totalidade, de modo a validar a exatid√£o e perfei√ß√£o na execu√ß√£o de suas fun√ß√µes.
- **Teste de Usabilidade:** Testa e simula as condi√ß√µes de utiliza√ß√£o do software sob a perspectiva do usu√°rio final. Esses testes focalizam a facilidade de navega√ß√£o entre as telas, clareza dos textos e as mensagens apresentadas ao usu√°rio, dentre outros aspectos da interface do sistema.
- **Testes de Progress√£o:** Testa apenas as funcionalidades (ou requisitos n√£o funcionais) especificadas para a vers√£o.
- **Teste de Fuma√ßa:** Teste o qual acontece rapidamente, executando as principais funcionalidades do sistema sem se preocupar com as condi√ß√µes de erro. √â o mesmo que o teste do "caminho feliz".

Existe na literatura a defini√ß√£o de uma t√©cnica de teste chamada "caixa cinza", a qual mescla as t√©cnicas de caixa preta com a caixa branca.

O sistema de software comercial tem de passar por tr√™s est√°gios de teste:

1. Testes em desenvolvimento, em que o sistema √© testado durante o desenvolvimento para descobrir bugs e defeitos. Projetistas de sistemas e programadores podem estar envolvidos no processo de teste.
2. Testes de release, em que uma equipe de teste independente testa uma vers√£o completa do sistema antes que ele seja liberado para os usu√°rios.
3. Testes de usu√°rio, em que os usu√°rios ou potenciais usu√°rios de um sistema testam o sistema em seu pr√≥prio ambiente.
4. Os testes de aceita√ß√£o s√£o uma categoria de teste de usu√°rio onde o cliente testa formalmente o sistema para decidir se ele deve ser aceite por parte do fornecedor do sistema ou se √© necess√°rio um desenvolvimento adicional.

---

# Evolu√ß√£o de Software

Depois que o software √© posto em funcionamento, com certeza ocorrer√£o mudan√ßas. Essas mudan√ßas podem ser para corre√ß√£o de erros n√£o detectados durante a etapa de valida√ß√£o do software, quando h√° adapta√ß√£o a um novo ambiente, quando o cliente solicita novas caracter√≠sticas ou fun√ß√µes, ou, ainda, quando a aplica√ß√£o passa por um processo de reengenharia para proporcionar benef√≠cio em um contexto moderno. 

Normalmente, os custos de manuten√ß√£o s√£o maiores que os custos de desenvolvimento inicial e considerados menos desafiadores.

Atualmente, os est√°gios de desenvolvimento e manuten√ß√£o t√™m sido considerados integrados e cont√≠nuos. 

![60-Evolu√ß√£o do Software](60-evolucao-software.png)

60-Evolu√ß√£o do Software

---

## Manuten√ß√£o de Software

Ap√≥s a implanta√ß√£o de um sistema, √© inevit√°vel que ocorram mudan√ßas, seja para pequenos ajustes ap√≥s a implanta√ß√£o, para melhorias substanciais, por for√ßa da legisla√ß√£o, para atender novos requisitos dos usu√°rios, ou por, finalmente, estar com erros.

Cerca de dois ter√ßos dos custos de software est√£o relacionados com a evolu√ß√£o do software, al√©m do consumo alto de tempo por parte da equipe de desenvolvimento em rela√ß√£o √† manuten√ß√£o e todas as implica√ß√µes que essa etapa carrega. 

Uma das raz√µes para o problema acerca da manuten√ß√£o de software se d√° na troca das pessoas que comp√µem as equipes de desenvolvimento, possivelmente a equipe que desenvolveu o software inicialmente j√° n√£o se encontre mais por perto, ou ainda, que ningu√©m esteja trabalhando atualmente na empresa. Nesse caso,  se o sistema desenvolvido estiver bem documentado e, em seu desenvolvimento, tenham sido seguidos os preceitos da engenharia de software, com certeza, sua altera√ß√£o se tornar√° mais f√°cil e √© poss√≠vel afirmar que o sistema apresenta uma alta manutenibilidade. 

A manuten√ß√£o do software √© importante, visto que o mundo muda rapidamente, demandadas por tecnologia de informa√ß√£o que suportem essas mudan√ßas e exig√™ncias no mercado imp√µem um ritmo de enorme press√£o competitiva a todas as organiza√ß√µes comerciais. Portanto, o software deve ser mantido continuamente, ou seja, deve passar por manuten√ß√µes constantemente. 

Existem tr√™s tipos diferentes de manuten√ß√£o:

1. **Corre√ß√£o de defeitos:** erros de codifica√ß√£o s√£o relativamente baratos para serem corrigidos e erros de projeto s√£o mais caros, pois podem implicar na reescrita de v√°rios componentes de programa. Erros de requisitos s√£o os mais caros para se corrigir, devido ao retrabalho (reprojeto) de sistema que pode ser necess√°rio.
2. **Adapta√ß√£o ambiental:** essa categoria manuten√ß√£o √© necess√°rio quando algum aspecto do ambiente do sistema, como o hardware, a plataforma do sistema operacional ou outro software de apoio, sofre uma mudan√ßa. O sistema de aplica√ß√£o deve ser modificado para se adaptar a essas mudan√ßas de ambiente.
3. **Adi√ß√£o de funcionalidade:** essa categoria de manuten√ß√£o √© necess√°rio quando os requisitos de sistema mudam em resposta √†s mudan√ßas organizacionais ou de neg√≥cios. A escala de mudan√ßas necess√°rias para o software √©, frequentemente, muito maior do que para as outras categorias de manuten√ß√£o.

Uma pesquisa realizada em empresas de desenvolvimento mostram que a manuten√ß√£o de software ocupa dois ter√ßos do or√ßamento de desenvolvimento. A pesquisa tamb√©m mostra que se gasta mais do or√ßamento na implementa√ß√£o de novos requisitos do que na corre√ß√£o de bugs.

![61-Distribui√ß√£o do esfor√ßo de manuten√ß√£o](61-distribuicao-esforco-manutencao.png)

61-Distribui√ß√£o do esfor√ßo de manuten√ß√£o

---

# Configura√ß√£o de Software

O Gerenciamento de Configura√ß√£o de Software (SCM ‚Äî *Software Configuration Management*) ou GCS √© uma atividade de apoio, do tipo "guarda-chuva aplicada no decorrer de toda a gest√£o de qualidade, destinada a gerenciar as mudan√ßas, identificando os artefatos que precisam ser alterados, as rela√ß√µes entre eles e o controle de vers√£o desses artefatos, controlando essas mudan√ßas, auditando e relatando todas as altera√ß√µes feitas no software.

As mudan√ßas podem ocorrer em qualquer instante, por isso, as atividades de SCM s√£o desenvolvidas para:

- Identificar a altera√ß√£o feita.
- Controlar a altera√ß√£o que est√° sendo feita.
- Assegurar que a altera√ß√£o esteja sendo implementada corretamente no software.
- Relatar as altera√ß√µes aos membros da equipe.

S√£o descritas quatro atividades de Gerenciamento de Configura√ß√£o de Software:

1. **Gerenciamento de mudan√ßas:** envolve manter o acompanhamento das solicita√ß√µes dos clientes e desenvolvedores por mudan√ßas no software, definir os custos e o impacto de fazer tais mudan√ßas, bem como decidir se e quando as mudan√ßas devem ser implementadas.
2. **Gerenciamento de vers√µes:** envolve manter o acompanhamento de v√°rias vers√µes de componentes do sistema e assegurar que as mudan√ßas nos componentes, realizadas por diferentes desenvolvedores, n√£o interferem uma nas outras.
3. **Constru√ß√£o do sistema:** √© o processo de montagem de componentes de programas, dados e bibliotecas e, em seguida, compila√ß√£o e liga√ß√£o destes, para criar um sistema execut√°vel.
4. **Gerenciamento de releases:** envolve a prepara√ß√£o de software para o release externo e manter o acompanhamento das vers√µes de sistema liberadas para uso do cliente.

<aside>
üí° Qual a diferen√ßa de suporte de software e gerenciamento de configura√ß√£o de software?

</aside>

> **Suporte** √© um conjunto de atividades de engenharia que ocorrem depois que o software foi fornecido ao cliente e posto em opera√ß√£o. 

**Gest√£o** **de configura√ß√£o** √© um conjunto de atividades de rastreamento e controle iniciadas quando um projeto de engenharia de software come√ßa e termina apenas quando o software sai de opera√ß√£o.
> 

![62-Atividades gerenciamento de configura√ß√£o de software](62-atividades-gerenciamento-configuracao-software.png)

62-Atividades gerenciamento de configura√ß√£o de software

A SCM possui um conjunto de atividades desenvolvidas para controlar as mudan√ßas que podem ocorrer ao longo do ciclo de vida de um software. Pode ser entendida como uma atividade de garantia de qualidade do sistema e pode ser aplicada em todo o processo do software. 

As informa√ß√µes resultantes do processo de software podem ser divididas em tr√™s categorias:

- Aplica√ß√µes (forma de c√≥digo-fonte ou execut√°vel).
- Produtos que descrevem os softwares (focado em v√°rios interessados do sistema ‚Äî analistas, desenvolvedores, testadores, suporte, etc.).
- Dados ou conte√∫do (contidos nos sistemas ou externos a eles).

Os itens que comp√µem todas as informa√ß√µes produzidas como parte do processo de software s√£o chamados coletivamente de configura√ß√£o de software. Conforme se avan√ßa no desenvolvimento do sistema, cria-se uma hierarquia dos itens de configura√ß√£o de software.

Um dos problemas do gerenciamento de configura√ß√£o, √© que muitas empresas falam sobre os mesmos conceitos usando termos diferentes:

| Termo | Descri√ß√£o |
| --- | --- |
| Item de configura√ß√£o u item de configura√ß√£o de software (SCI, Software Configuration Item) | Qualquer coisa associada a um projeto de software (projeto, c√≥digo, dados de teste, documentos, etc) que tenha sido colocado sob controle de configura√ß√£o. Muitas vezes, existem diferentes vers√µes de um item de configura√ß√£o. Itens de configura√ß√£o t√™m um nome √∫nico.  |
| Controle de Configura√ß√£o | O processo de garantia de que vers√µes de sistemas e componentes sejam registradas e mantidas para que as mudan√ßas sejam gerenciadas e todas as vers√µes de componentes sejam identificadas e armazenadas por todo o tempo de vida do sistema. |
| Vers√£o | Uma inst√¢ncia de um item de configura√ß√£o que difere de alguma forma, de outras inst√¢ncias deste item. As vers√µes sempre t√™m um identificador √∫nico, o qual √© geralmente composto pelo nome do item de configura√ß√£o mais um n√∫mero de vers√£o. |
| Baseline | Uma baseline √© uma cole√ß√£o de vers√µes de componentes que comp√µem um sistema. As baselines s√£o controladas, o que significa que as vers√µes dos componentes que constituem o sistema, n√£o podem ser alteradas. Isso significa que deveria sempre ser poss√≠vel recriar uma baseline a partir de seus componentes. |
| Codeline | Uma codeline √© um conjunto de vers√µes de um componente de software e outros itens de configura√ß√£o dos quais esse componente depende. |
| Mainline | Trata-se de uma sequ√™ncia de baselines que representam diferentes vers√µes de um sistema.  |
| Release | Uma vers√£o de um sistema liberada para os clientes (ou outros usu√°rios em uma organiza√ß√£o) para uso. |
| Branching | Trata-se da cria√ß√£o de uma nova codeline de uma vers√£o em uma codeline existente. A nova codeline e uma codeline podem, ent√£o, ser desenvolvidas independentemente. |
| Merging | Trata-se da cria√ß√£o de uma nova vers√£o de um componente de software, fundindo vers√µes separadas em diferentes codelines. Essas codelines podem ter sido criadas por um branch anterior de uma das codelines envolvidas. |

---